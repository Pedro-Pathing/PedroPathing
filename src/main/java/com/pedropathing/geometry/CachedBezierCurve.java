package com.pedropathing.geometry;

import androidx.annotation.NonNull;

import com.pedropathing.math.MathFunctions;
import com.pedropathing.math.Matrix;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class CachedBezierCurve {

    private Vector<Pose> controlPoints;

    private com.pedropathing.math.Vector endTangent = new com.pedropathing.math.Vector();

    private final int APPROXIMATION_STEPS = 1000;

    private final int DASHBOARD_DRAWING_APPROXIMATION_STEPS = 100;

    private double[][] dashboardDrawingPoints;

    private double UNIT_TO_TIME;
    private double length;

    private Matrix cachedMatrix;

    private int[][] diffPowers;
    private int[][] diffCoefficients;

    public CachedBezierCurve() {
    }

    public CachedBezierCurve(List<Pose> controlPoints){
        if (controlPoints.size()<3) {
            try {
                throw new Exception("Too few control points");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        this.controlPoints = new Vector<>(controlPoints);
        initialize();
    }

    /**
     * This handles most of the initialization of the BezierCurve that is called from the constructor.
     */
    public void initialize() {
        generateBezierCurve();
        length = approximateLength();
        UNIT_TO_TIME = 1.0d/length;
        endTangent.setOrthogonalComponents(controlPoints.lastElement().getX()-controlPoints.get(controlPoints.size()-2).getX(), controlPoints.lastElement().getY()-controlPoints.get(controlPoints.size()-2).getY());
        endTangent = MathFunctions.normalizeVector(endTangent);
        initializeDashboardDrawingPoints();
    }

    /**
     * This creates the Array that holds the Points to draw on the Dashboard.
     */
    public void initializeDashboardDrawingPoints() {
        this.dashboardDrawingPoints = new double[2][this.DASHBOARD_DRAWING_APPROXIMATION_STEPS + 1];
        for (int i = 0; i <= this.DASHBOARD_DRAWING_APPROXIMATION_STEPS; i++) {
            Pose currentPoint = this.getPose(i/(double) (this.DASHBOARD_DRAWING_APPROXIMATION_STEPS));
            this.dashboardDrawingPoints[0][i] = currentPoint.getX();
            this.dashboardDrawingPoints[1][i] = currentPoint.getY();
        }
    }

    /**
     * This returns a 2D Array of doubles containing the x and y positions of points to draw on FTC
     * Dashboard.
     *
     * @return returns the 2D Array to draw on FTC Dashboard
     */
    public double[][] getDashboardDrawingPoints() {
        return this.dashboardDrawingPoints;
    }

    /**
     * This generates the Bezier curve. It assumes that the ArrayList of control points has been set.
     * This caches the matrix generated by multiplying the characteristic matrix and the matrix where each control
     * point is a row vector.
     */
    public void generateBezierCurve() {
        this.cachedMatrix = BezierCurveMatrixSupplier.getCharacteristicMatrix(this.controlPoints.size() - 1);
        Matrix controlPointMatrix = new Matrix(this.controlPoints.size(), 2);
        for (int i = 0; i < this.controlPoints.size(); i++) {
            Pose p = this.controlPoints.get(i);
            controlPointMatrix.set(i, new double[]{p.getX(), p.getY()});
        }
        this.cachedMatrix.multiply(controlPointMatrix);
        initializeDegreeArray();
        initializeCoefficientArray();
    }

    /**
     * This returns the unit tangent Vector at the end of the BezierCurve.
     *
     * @return returns the end tangent Vector.
     */
    public com.pedropathing.math.Vector getEndTangent() {
        return MathFunctions.copyVector(endTangent);
    }

    /**
     * This approximates the length of the BezierCurve in APPROXIMATION_STEPS number of steps. It's
     * like a Riemann's sum, but for a parametric function's arc length.
     *
     * @return returns the approximated length of the BezierCurve.
     */
    public double approximateLength() {
        Pose previousPoint = getPose(0);
        Pose currentPoint;
        double approxLength = 0;
        for (int i = 1; i <= APPROXIMATION_STEPS; i++) {
            currentPoint = getPose(i/(double)APPROXIMATION_STEPS);
            approxLength += previousPoint.distanceFrom(currentPoint);
            previousPoint = currentPoint;
        }
        return approxLength;
    }

    /**
     * Initializes the degree/power array (for later processing) and cache them
     */
    public void initializeDegreeArray(){
        int deg = this.controlPoints.size() - 1;
        // for now, cache position, velocity, and acceleration powers (thus 3) per bezier obj (change to global caching later)
        this.diffPowers = new int[3][this.controlPoints.size()];

        for (int i = 0; i < this.diffPowers.length; i++) {
            this.diffPowers[i] = CachedBezierCurve.genDiff(deg, i);
        }
    }

    /**
     * Generate and return a polynomial's powers at the differentiation level
     * @param deg degree of poly
     * @param diffLevel number of differentiations
     * @return powers of each term in integers
     */
    private static int[] genDiff(int deg, int diffLevel){
        int[] output = new int[deg + 1];

        for (int i = diffLevel; i < output.length; i++) {
            output[i] = i - diffLevel;
        }

        return output;
    }

    /**
     * Initializes the coefficient array (for later processing) and cache them.
     * Each row is a different level of differentiation.
     */
    public void initializeCoefficientArray(){
        // for now, cache coefficients for the 0th, 1st, and 2nd derivatives (change to global caching later)
        this.diffCoefficients = new int[3][this.controlPoints.size()];

        Arrays.fill(this.diffCoefficients[0], 1);

        for (int row = 1; row < this.diffCoefficients.length; row++) {
            for (int col = 0; col < this.diffCoefficients[0].length; col++) {
                this.diffCoefficients[row][col] = this.diffCoefficients[row - 1][col] * this.diffPowers[row - 1][col];
            }
        }
    }

    /**
     * This method gets the t-vector at the specified differentiation level.
     * @param t t value of the parametric curve; [0, 1]
     * @param diffLevel specifies how many differentiations are done
     * @return t vector
     */
    public double[] getTVector(double t, int diffLevel){
        int[] degrees = this.diffPowers[diffLevel];
        double[] powers = new double[this.controlPoints.size()];

        powers[0] = 1;
        for (int i = 1; i < powers.length; i++) {
            powers[i] = t * powers[i - 1];
        }

        double[] output = new double[powers.length];

        for (int i = 0; i < degrees.length; i++) {
            output[i] = powers[degrees[i]] * this.diffCoefficients[diffLevel][i];
        }

        return output;
    }

    /**
     * This returns the point on the Bezier curve that is specified by the parametric t value. A
     * Bezier curve is a parametric function that returns points along it with t ranging from [0, 1],
     * with 0 being the beginning of the curve and 1 being at the end. The Follower will follow
     * BezierCurves from 0 to 1, in terms of t.
     *
     * @param t this is the t value of the parametric curve. t is clamped to be between 0 and 1 inclusive.
     * @return this returns the point requested.
     */
    public Pose getPose(double t) {
        t = MathFunctions.clamp(t, 0, 1);

        Matrix outPos = new Matrix(new double[][]{getTVector(t, 0)});
        outPos.multiply(this.cachedMatrix);
        return new Pose(outPos.get(0, 0), outPos.get(0, 1));
    }

    /**
     * This returns the curvature of the Bezier curve at a specified t-value.
     *
     * @param t the parametric t input.
     * @return returns the curvature.
     */
    public double getCurvature(double t) {
        t = MathFunctions.clamp(t, 0, 1);

        com.pedropathing.math.Vector derivative = getDerivative(t);
        com.pedropathing.math.Vector secondDerivative = getSecondDerivative(t);

        if (derivative.getMagnitude() == 0) return 0;
        return (MathFunctions.crossProduct(derivative, secondDerivative))/Math.pow(derivative.getMagnitude(),3);
    }

    /**
     * This returns the derivative on the BezierCurve that is specified by the parametric t value.
     * This is returned as a Vector, and this Vector is the tangent to the BezierCurve.
     *
     * @param t this is the t value of the parametric curve. t is clamped to be between 0 and 1 inclusive.
     * @return this returns the derivative requested.
     */
    public com.pedropathing.math.Vector getDerivative(double t) {
        t = MathFunctions.clamp(t, 0, 1);

        Matrix outVel = new Matrix(new double[][]{getTVector(t, 1)});
        outVel.multiply(this.cachedMatrix);
        com.pedropathing.math.Vector output = new com.pedropathing.math.Vector();
        output.setOrthogonalComponents(outVel.get(0, 0), outVel.get(0, 1));
        return output;
    }

    /**
     * This returns the second derivative on the BezierCurve that is specified by the parametric t value.
     * This is returned as a Vector, and this Vector is the acceleration on the BezierCurve.
     *
     * @param t this is the t value of the parametric curve. t is clamped to be between 0 and 1 inclusive.
     * @return this returns the second derivative requested.
     */
    public com.pedropathing.math.Vector getSecondDerivative(double t) {
        t = MathFunctions.clamp(t, 0, 1);

        Matrix outAccel = new Matrix(new double[][]{getTVector(t, 2)});
        outAccel.multiply(this.cachedMatrix);
        com.pedropathing.math.Vector output = new com.pedropathing.math.Vector();
        output.setOrthogonalComponents(outAccel.get(0, 0), outAccel.get(0, 1));
        return output;
    }

    /**
     * This method calculates the position, velocity, and acceleration and puts them into a matrix
     * as row vectors.
     * @param t t value of the parametric curve; [0, 1]
     * @return matrix with row vectors corresponding to position, velocity, and acceleration at the requested t value
     */
    public Matrix getPointCharacteristics(double t){
        t = MathFunctions.clamp(t, 0, 1);

        Matrix output = new Matrix(new double[][]{
                getTVector(t, 0),
                getTVector(t, 1),
                getTVector(t, 2)
        });
        output.multiply(this.cachedMatrix);
        return output;
    }

    /**
     * Because, for whatever reason, the second derivative returned by the getSecondDerivative(double t)
     * method doesn't return the correct heading of the second derivative, this gets an approximate
     * second derivative essentially using the limit method. I use this for its heading only.
     *
     * @param t this is the t value of the parametric curve. t is clamped to be between 0 and 1 inclusive.
     * @return this returns the approximated second derivative.
     */
    public com.pedropathing.math.Vector getApproxSecondDerivative(double t) {
        double current = getDerivative(t).getTheta();
        double deltaCurrent = getDerivative(t + 0.0001).getTheta();

        return new com.pedropathing.math.Vector(1, deltaCurrent - current);
    }

    /**
     * Returns the ArrayList of control points for this BezierCurve.
     *
     * @return This returns the control points.
     */
    public Vector<Pose> getControlPoints() {
        return controlPoints;
    }

    /**
     * Returns the first control point for this BezierCurve.
     *
     * @return This returns the Point.
     */
    public Pose getFirstControlPoint() {
        return controlPoints.get(0);
    }

    /**
     * Returns the second control point, or the one after the start, for this BezierCurve.
     *
     * @return This returns the Point.
     */
    public Pose getSecondControlPoint() {
        return controlPoints.get(1);
    }

    /**
     * Returns the second to last control point for this BezierCurve.
     *
     * @return This returns the Point.
     */
    public Pose getSecondToLastControlPoint() {
        return controlPoints.get(controlPoints.size()-2);
    }

    /**
     * Returns the last control point for this BezierCurve.
     *
     * @return This returns the Point.
     */
    public Pose getLastControlPoint() {
        return controlPoints.get(controlPoints.size()-1);
    }

    /**
     * Returns the approximate length of this BezierCurve.
     *
     * @return This returns the length.
     */
    public double length() {
        return length;
    }

    /**
     * Returns the conversion factor of one unit of distance into t-value. Since parametric functions
     * are defined by t, which can mean time, I use "time" in some method names for conciseness.
     *
     * @return returns the conversion factor.
     */
    public double UNIT_TO_TIME() {
        return UNIT_TO_TIME;
    }

    /**
     * Returns the type of path. This is used in case we need to identify the type of BezierCurve
     * this is.
     *
     * @return returns the type of path.
     */
    public String pathType() {
        return "curve";
    }


    /**
     * Returns a clone of the BezierCurve.
     *
     * @return returns the coefficients.
     */
    @NonNull
    public CachedBezierCurve clone() {
        CachedBezierCurve clone = new CachedBezierCurve();
        clone.controlPoints = new Vector<>(controlPoints);
        clone.endTangent = MathFunctions.copyVector(endTangent);
        clone.length = length;
        clone.UNIT_TO_TIME = UNIT_TO_TIME;
        clone.dashboardDrawingPoints = new double[dashboardDrawingPoints.length][];
        for (int i = 0; i < dashboardDrawingPoints.length; i++) {
            clone.dashboardDrawingPoints[i] = dashboardDrawingPoints[i].clone();
        }
        return clone;
    }

    /**
     * Returns a new BezierCurve with the control points reversed.
     *
     * @return a new BezierCurve with reversed control points.
     */
    public CachedBezierCurve getReversed() {
        Vector<Pose> reversedControlPoints = new Vector<>(controlPoints);
        Collections.reverse(reversedControlPoints);
        CachedBezierCurve reversedCurve = new CachedBezierCurve(reversedControlPoints);

        // Recalculate coefficients, tangents, and drawing points
        reversedCurve.generateBezierCurve();
        reversedCurve.length = reversedCurve.approximateLength();
        reversedCurve.UNIT_TO_TIME = 1 / reversedCurve.length;
        reversedCurve.endTangent.setOrthogonalComponents(
                reversedCurve.controlPoints.get(reversedCurve.controlPoints.size() - 1).getX() -
                        reversedCurve.controlPoints.get(reversedCurve.controlPoints.size() - 2).getX(),
                reversedCurve.controlPoints.get(reversedCurve.controlPoints.size() - 1).getY() -
                        reversedCurve.controlPoints.get(reversedCurve.controlPoints.size() - 2).getY()
        );
        reversedCurve.endTangent = MathFunctions.normalizeVector(reversedCurve.endTangent);
        reversedCurve.initializeDashboardDrawingPoints();

        return reversedCurve;
    }
}
